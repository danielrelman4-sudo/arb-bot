# Consolidated Master Plan: Dry-Run to Live Trading Readiness

## Context

The arb bot has mature detection, sizing, and paper simulation, but critical gaps in post-execution lifecycle (order tracking, crash recovery, legging safety), operational controls (kill switches, circuit breakers), and execution latency (Python too slow for live edge capture) make it unsafe for real money. This plan consolidates **all 59 existing backlog items** plus **6 new items** identified during code review into a single dependency-ordered, safety-first roadmap. The Rust hot-path migration is a prerequisite for live trading — Python latency cannot capture real edge on live markets.

Every item from the original backlog appears exactly once in the cross-reference table at the bottom.

---

## PHASE 0: Crash Safety and Order Lifecycle (Week 1-2)

**Why first:** A crash between leg A filling and leg B submitting leaves an unhedged position with no record. This is the #1 capital-loss risk.

### 0A. Persistent order/position store (SQLite) — [NEW 60]
- New module `arb_bot/order_store.py` with SQLite-backed `order_intents` and `positions` tables
- Write intent row BEFORE calling `place_single_order()`, update on response
- Back `EngineState` in-memory dicts (`cash_by_venue`, `locked_capital_by_venue`, `open_markets_by_venue`) from store on startup

### 0B. Legging risk controls — [Backlog 32]
- Execute cross-venue legs sequentially (not `asyncio.gather`) in `_execute_live_plan` (engine.py:2112)
- After leg A fills: re-check leg B quote freshness, abort + cancel leg A if book moved beyond tolerance
- Max time window between leg fills (config param), cancel/unwind/hedge fallback on miss

### 0C. Cancel/replace for unfilled legs — [NEW 65]
- Add `cancel_order()` and `get_order_status()` to `ExchangeAdapter` ABC (exchanges/base.py)
- Implement for Kalshi (10s expiry needs re-submit logic) and Polymarket

### 0D. Post-submission order status polling — [NEW 63]
- Poll order status after placement to verify fills, update persistent store
- Timeout triggers cancel/unwind policy from 0B

### 0E. Partial fill handling — [NEW 64]
- Track per-leg fill state in persistent store
- Compute hedged vs exposed portion, decide close/wait for exposed remainder

### 0F. Crash recovery startup — [NEW 61]
- On boot: read persistent store, reconcile against exchange account/position APIs
- Unhedged positions discovered → safe mode (no new trades until operator acknowledges)

### 0G. Automatic balance refresh — [NEW 62]
- Periodic venue balance refresh on timer (default 60s) instead of only at `run_once` start
- Auto-release stale locked capital by reconciling against exchange balance

**Exit gate:** Crash mid-execution recovers to correct state on reboot. Leg-A-fills/leg-B-fails triggers cancel and store reflects correct state. All existing tests pass.

---

## PHASE 1: Kill Switches and Circuit Breakers (Week 2-3)

**Why second:** With persistent state, we need the ability to halt the bot before it loses more money.

### 1A. Operational risk controls — [Backlog 17]
- Global kill switch (file/env), per-venue kill switch, daily loss cap, max consecutive failures, canary mode

### 1B. Circuit breakers and auto-pause — [Backlog 34]
- Data-health-triggered pause, explicit recovery criteria before auto-resume

### 1C. Endpoint-specific circuit breakers — [Backlog 41]
- Independent per-endpoint circuits (kalshi `/markets`, `/events`, `/orderbook`; polymarket book), jittered probe recovery

### 1D. Automatic mode degradation with hysteresis — [Backlog 39]
- Deterministic failover: stream → hybrid → poll-only, hysteresis to prevent flapping

### 1E. Pre-run hard gate wrapper — [Backlog 38]
- Startup gate chain (stream preflight + dual-venue smoke + phase0 mini-gate), abort if red

### 1F. Process supervision policy — [Backlog 46]
- launchd/systemd/container config, crash-loop detection, safe-stop, restart invokes crash recovery (0F)

**Exit gate:** Kill switch halts orders within 1 cycle. Daily loss cap triggers halt before threshold. Circuit breaker opens on simulated 429 storm and recovers.

---

## PHASE 2: Data Quality and Measurement Baseline (Week 3-4)

**Why third:** Before optimizing, we need trustworthy signals and trustworthy measurement.

### 2A. Pre-trade quote and mapping risk gates — [Backlog 31]
- Strict quote sanity/staleness checks and mapping-confidence minimums before planning

### 2B. Quote sanity firewall hardening — [Backlog 51 / Gate]
- Reject micro-price artifacts, stale/degenerate books, impossible quote states, price jump anomaly guards

### 2C. Delta/snapshot reconciliation loop — [Backlog 8]
- Periodic REST snapshot vs WebSocket state reconciliation, per-market checksum/version, force resync on divergence

### 2D. Stream ingestion hardening — [Backlog 7]
- Bounded per-venue queues with backpressure/drop policy, stream health watchdogs (heartbeat lag, reconnect rate, gap rate)

### 2E. Deterministic dedupe + idempotency keys — [Backlog 9]
- Stable opportunity IDs (kind + legs + style + time bucket), idempotent order intents via persistent store

### 2F. Market mapping QA pipeline — [Backlog 10]
- Validate mapping cardinality, stale links, semantic drift; auto-flag suspicious mappings

### 2G. Long-run storage + analytics pipeline — [Backlog 13]
- DuckDB/Parquet store with partitioning and retention, daily summary jobs (lane conversion, fill-quality drift, concentration)

### 2H. Metrics export + alert dashboard — [Backlog 44]
- Prometheus/StatsD export (coverage, readiness, skip-reason, 429, reconnect), alert thresholds, pager signals

**Exit gate:** Zero invalid-quote opens in audit sample. Stream/snapshot reconciliation corrects injected drift within 2 refresh cycles. Reproducible KPI report for every paper run. DuckDB queryable for daily summaries.

**Primetime gates achievable:** Identification quality benchmark [48], Mapping integrity [49], Structural rule confidence labeling [50], Quote sanity firewall [51], Cross/parity family canonicalization [52]

---

## PHASE 3: Execution Quality and Cost Realism (Week 4-5)

**Why fourth:** With reliable data, improve execution modeling so paper results predict live results.

### 3A. Execution realism upgrades — [Backlog 14]
- Independent leg fill paths, queue position decay, leg slippage (replace scalar fill model in engine.py:2154)

### 3B. Fill and slippage calibration — [Backlog 53 / Gate]
- Calibrate fill/slippage model against paper-forward realized outcomes using DuckDB store

### 3C. Execution-cost completeness — [Backlog 54 / Gate]
- Complete fee/friction accounting per venue and order type, reconcile vs venue statements

### 3D. Maker-first live execution policy — [Backlog 1]
- Passive entry when queue/fill model implies positive EV net of adverse selection, taker fallback

### 3E. Latency SLO + auto-throttle — [Backlog 2]
- First-class SLOs for quote age / decision latency / execution latency, auto-throttle on persistent breaches

### 3F. Low-latency execution path optimization — [Backlog 22]
- Split detection and execution workers, pre-build signed request components, measure detect-to-ack p95

**Exit gate:** Realized/expected ratio inside target band on multi-hour paper. Cost reconciliation shows no systematic underestimation. Latency p95 measured and below threshold.

**Primetime gates achievable:** Fill and slippage calibration [53], Execution-cost completeness [54]

---

## PHASE 4: Sizing Safety and Risk Framework (Week 5-6)

**Why fifth:** Accurate execution modeling is a prerequisite for reliable sizing and risk controls.

### 4A. Tail-risk-aware Kelly sizing — [Backlog 24]
- Uncertainty haircuts per lane/family, reduce Kelly when model error/variance increases (sizing.py)

### 4B. Liquidity impact curve integration — [Backlog 25]
- Empirically learned slippage/impact curves, auto size-down when marginal impact erodes edge

### 4C. Confidence-scaled max-loss cap — [Backlog 27]
- Worst-case loss cap under model-error scenarios, tighter caps for low-confidence opportunities

### 4D. Outlier-robust sizing inputs — [Backlog 28]
- Block/downweight suspicious quote states in sizing, prevent anomalous books from driving oversized positions

### 4E. Time-to-resolution capital lock penalty — [Backlog 29]
- Carry/lock-up penalty for long-duration positions, require higher edge for slower-resolving opportunities

### 4F. Drawdown-adaptive de-risking — [Backlog 30]
- Auto-reduce sizing when rolling realized underperforms expected, restore gradually after recovery criteria met

### 4G. Dynamic per-lane bankroll allocation — [Backlog 26]
- Adaptive allocation across lanes by realized risk-adjusted efficiency, prevent over-allocation to deteriorating lanes

### 4H. Exposure and concentration controls — [Backlog 33]
- Hard caps by venue, market family, and correlation cluster; max concurrent at-risk positions per lane/family (risk.py)

### 4I. Expected-vs-realized drift monitoring — [Backlog 36]
- Track drift by lane/family, trigger de-risk mode on sustained negative drift, alerting + auto throttle-down

### 4J. Lane readiness watchdog enforcement — [Backlog 35]
- Auto-pause lanes below coverage/readiness thresholds, prevent trading on partial/broken signal state

**Exit gate:** Fault-injection triggers expected de-risk behavior. No outsized positions from low-confidence inputs in 24h paper run. Drawdown-adaptive sizing reduces exposure during simulated drawdown.

**Primetime gates achievable:** Outlier robustness in reporting [55]

---

## PHASE 5: Reliability and Operational Readiness (Week 6-7)

**Why sixth:** All safety systems in place; now harden for unattended multi-hour/multi-day operation.

### 5A. Adaptive per-endpoint API rate governor — [Backlog 18]
- AIMD + token buckets per venue/endpoint, Retry-After parsing (replace basic `_endpoint_next_request_ts` in kalshi.py)

### 5B. Tiered polling scheduler — [Backlog 19]
- Hot/warm/cold tiers (sub-second to minutes), promote on stream updates/positions/opportunities, auto-demote inactive

### 5C. Poll budget allocator + fairness — [Backlog 20]
- Budget across lanes/venues per cycle, prevent starvation, strict ceilings + burst allowances

### 5D. Cross/parity coverage watchdog — [Backlog 21]
- Track `cross_pairs_covered` / `parity_rules_covered` as health metrics, targeted repair on threshold breach

### 5E. Cross/parity keepalive probe set — [Backlog 42]
- Low-rate probes for mapped pairs/rules, alert on coverage floor breach

### 5F. Dual-venue bootstrap budget enforcement — [Backlog 40]
- Reserve startup API budget for mapped overlap symbols, prevent one-venue starvation

### 5G. Persistent warm-cache snapshots — [Backlog 43]
- Persist quote cache + coverage state, reload at startup, reduce time-to-readiness after restarts

### 5H. Initialization speed + startup progress — [Backlog 16]
- Parallelize discovery/bootstrap, cache warm starts, startup progress logs with timings, timeout/fail-fast path

### 5I. Parallel lane execution architecture — [Backlog 11]
- Isolated lane workers with bounded fan-out, deterministic merge, per-lane timing metrics + timeout budgets

### 5J. Dynamic capacity controller — [Backlog 15]
- Auto-adjust universe size/scoring depth/scan cadence by CPU/memory/API/latency budgets

### 5K. Operational failure handling playbooks — [Backlog 37]
- Codified runbooks for 429 storms, stream disconnect loops, venue outages; deterministic fail-safe behavior

### 5L. Secret and credential hardening — [Backlog 45]
- OS keychain/secret manager, key-scope/expiry validation, rotation runbook

### 5M. Incident replay bundle automation — [Backlog 47]
- One-command export of run artifacts (logs, config, coverage, decisions), consumable by replay harness

### 5N. Replay + deterministic simulation harness — [Backlog 12]
- Record raw stream/poll events + decisions, deterministic replay, A/B profile replay on identical data

**Exit gate:** 8+ hour paper session with stable coverage and no critical regressions. Rate governor backs off on 429 storms and recovers. Cold start time below target.

**Primetime gates achievable:** Lane health SLOs [56], Long-run stability test [57]

---

## PHASE 6: Signal Intelligence and Strategy Upgrades (Week 7-8)

**Note:** Phase 6 and Phase 7 (Rust migration) can proceed in parallel if resources allow, since they have no dependencies on each other. Both must complete before Phase 8 (live canary).

**Why seventh:** System is safe and reliable; now improve signal quality and strategy sophistication.

### 6A. Confidence-scored strict mapping mode — [Backlog 23]
- Strict map primary, gated confidence fallback with multi-signal agreement, separate audit logging

### 6B. Event-tree basket coverage — [Backlog 6]
- Robust rule generation from real parent/child metadata, payout math validation, diagnostics, paper experiments

### 6C. Auto dependency discovery — [Backlog 5]
- Detect likely market-link constraints from text + co-movement, propose rules for human review

### 6D. Hold-time / exit discipline engine — [Backlog 4]
- Close/hedge/abandon logic on edge decay or risk rise, time-stop and EV-stop exits

### 6E. KPI-driven auto-tuning loop — [Backlog 3]
- Periodic threshold adjustment from paper KPIs, bounded parameter ranges, minimum sample sizes

**Exit gate:** Event-tree lane contributes non-trivially to paper PnL across 2+ multi-hour sessions. Auto-tuning produces no degenerate parameters in 48h run.

---

## PHASE 7: Rust Migration (Week 8-10)

**Why before live:** Python is too slow to capture real edge on live markets. The hot-path latency improvement from Rust is essential for any live trading to be profitable. This must be complete before canary deployment.

### 7A. Migration design and parity harness — [Backlog 59]
- Define hot-path modules to port first: opportunity scan, quote normalization, sizing/eval
- Lock Python-to-Rust parity tests: identical inputs must produce identical outputs across both implementations
- Design FFI/service boundary (PyO3 extension module vs separate process with IPC)
- Establish performance SLOs: latency targets (detect-to-plan p95/p99), throughput (quotes/sec), CPU/memory budgets

### 7B. Hot-path implementation
- Port quote normalization and binary math (highest call frequency, simplest logic)
- Port opportunity detection (5 lanes — largest latency contributor)
- Port sizing/eval (Kelly, fill model, ranking)
- Each module: implement in Rust, validate parity, benchmark vs Python baseline

### 7C. Integration and cutover
- Wire Rust modules into Python engine via chosen boundary (PyO3 recommended for lowest-latency path)
- Run parallel Python + Rust execution in paper mode, compare outputs for drift
- Staged cutover: one module at a time, rollback path for each
- Final benchmark: full cycle latency end-to-end must meet SLOs

**Exit gate:** All hot-path modules ported. Parity tests pass. Latency SLOs met. Multi-hour paper session with Rust hot path shows no regression vs Python-only baseline in detection quality.

---

## PHASE 8: Live-Forward Canary Rollout (Week 10+)

**Why last:** All phases including Rust migration must pass before live capital.

### 8A. Live-forward canary protocol — [Backlog 58 / Gate]
- **Stage 1:** $25-50, kill switches armed, 1-2 lanes (intra-venue + one cross-venue pair)
- **Stage 2:** $100-200, all lanes, 48h minimum
- **Stage 3:** Scale to target notional after gate pass

### 8B. Primetime readiness gate evaluation
- Run full gate checklist before Stage 1, re-run between each stage promotion

**Exit gate:** Each stage passes realized PnL, drawdown, execution reliability thresholds. Zero unacknowledged unhedged positions. Rust hot path running in production.

---

## PRIMETIME READINESS GATES

All must be green before Phase 8 Stage 1.

| Gate | Phase |
|------|-------|
| Identification quality benchmark [48] | 2 |
| Mapping integrity and drift checks [49] | 2 |
| Structural rule confidence labeling [50] | 2 |
| Quote sanity firewall hardening [51] | 2 |
| Cross/parity family canonicalization [52] | 2 |
| Fill and slippage calibration [53] | 3 |
| Execution-cost completeness [54] | 3 |
| Outlier robustness in reporting [55] | 4 |
| Lane health SLOs [56] | 5 |
| Long-run stability test [57] | 5 |
| Rust hot-path latency SLOs [59] | 7 |
| Live-forward canary protocol [58] | 8 |

---

## ITEM-TO-PHASE CROSS-REFERENCE

| # | Item | Phase |
|---|------|-------|
| 1 | Maker-first live execution policy | 3D |
| 2 | Latency SLO + auto-throttle | 3E |
| 3 | KPI-driven auto-tuning loop | 6E |
| 4 | Hold-time / exit discipline engine | 6D |
| 5 | Auto dependency discovery | 6C |
| 6 | Event-tree basket coverage | 6B |
| 7 | Stream ingestion hardening | 2D |
| 8 | Delta/snapshot reconciliation | 2C |
| 9 | Deterministic dedupe + idempotency | 2E |
| 10 | Market mapping QA pipeline | 2F |
| 11 | Parallel lane execution | 5I |
| 12 | Replay + simulation harness | 5N |
| 13 | Long-run storage + analytics | 2G |
| 14 | Execution realism upgrades | 3A |
| 15 | Dynamic capacity controller | 5J |
| 16 | Initialization speed + startup | 5H |
| 17 | Operational risk controls | 1A |
| 18 | Adaptive API rate governor | 5A |
| 19 | Tiered polling scheduler | 5B |
| 20 | Poll budget allocator + fairness | 5C |
| 21 | Cross/parity coverage watchdog | 5D |
| 22 | Low-latency execution path | 3F |
| 23 | Confidence-scored strict mapping | 6A |
| 24 | Tail-risk-aware Kelly sizing | 4A |
| 25 | Liquidity impact curve | 4B |
| 26 | Dynamic per-lane bankroll | 4G |
| 27 | Confidence-scaled max-loss cap | 4C |
| 28 | Outlier-robust sizing inputs | 4D |
| 29 | Time-to-resolution lock penalty | 4E |
| 30 | Drawdown-adaptive de-risking | 4F |
| 31 | Pre-trade quote/mapping gates | 2A |
| 32 | Legging risk controls | 0B |
| 33 | Exposure + concentration controls | 4H |
| 34 | Circuit breakers + auto-pause | 1B |
| 35 | Lane readiness watchdog | 4J |
| 36 | Expected-vs-realized drift | 4I |
| 37 | Operational failure playbooks | 5K |
| 38 | Pre-run hard gate wrapper | 1E |
| 39 | Auto mode degradation + hysteresis | 1D |
| 40 | Dual-venue bootstrap budget | 5F |
| 41 | Endpoint-specific circuit breakers | 1C |
| 42 | Cross/parity keepalive probes | 5E |
| 43 | Persistent warm-cache snapshots | 5G |
| 44 | Metrics export + alert dashboard | 2H |
| 45 | Secret + credential hardening | 5L |
| 46 | Process supervision policy | 1F |
| 47 | Incident replay bundle | 5M |
| 48 | Identification quality gate | Primetime/2 |
| 49 | Mapping integrity gate | Primetime/2 |
| 50 | Structural rule confidence gate | Primetime/2 |
| 51 | Quote sanity firewall gate | Primetime/2 |
| 52 | Cross/parity family gate | Primetime/2 |
| 53 | Fill + slippage calibration gate | Primetime/3 |
| 54 | Execution-cost completeness gate | Primetime/3 |
| 55 | Outlier robustness gate | Primetime/4 |
| 56 | Lane health SLOs gate | Primetime/5 |
| 57 | Long-run stability gate | Primetime/5 |
| 58 | Live-forward canary gate | Primetime/8 |
| 59 | Rust migration (hot-path port) | 7A-7C |
| 60 | Persistent order/position store | 0A |
| 61 | Crash recovery startup | 0F |
| 62 | Automatic balance refresh | 0G |
| 63 | Post-submission order status polling | 0D |
| 64 | Partial fill handling | 0E |
| 65 | Cancel/replace for unfilled legs | 0C |

---

## KEY FILES

- `arb_bot/engine.py` — Core engine, `_execute_live_plan` (line 2069), in-memory state management
- `arb_bot/exchanges/base.py` — ExchangeAdapter ABC (needs `cancel_order`, `get_order_status`, `get_positions`)
- `arb_bot/exchanges/kalshi.py` — Kalshi API + WebSocket (order placement line 1678, auth line 1746)
- `arb_bot/exchanges/polymarket.py` — Polymarket API + WebSocket (order placement line 777)
- `arb_bot/risk.py` — RiskManager `precheck` and `record_fill` (needs kill switches, daily loss, concentration)
- `arb_bot/sizing.py` — PositionSizer `execution_aware_kelly_fraction` (line 127, needs Phase 4 modifications)
- `arb_bot/models.py` — EngineState (line 201), execution result types (needs persistent state extension)
- `arb_bot/paper.py` — Paper simulation (needs Phase 3 execution realism upgrades)
- `arb_bot/config.py` — Configuration (needs new params for all phases)
- `arb_bot/order_store.py` — NEW: persistent SQLite store (Phase 0)

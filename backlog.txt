# Backlog

- [ ] Maker-first live execution policy
  - Prefer passive entry when queue/fill model implies positive expected value net of adverse-selection risk.
  - Fall back to taker only when expected realized edge stays above threshold.

- [ ] Latency SLO + auto-throttle
  - Track quote age / decision latency / execution latency as first-class SLOs.
  - Auto-throttle or skip markets/venues when stale-data or latency breaches are persistent.

- [ ] KPI-driven auto-tuning loop
  - Periodically adjust thresholds (edge, fill quality, fill probability, sizing caps) from paper-trade KPIs.
  - Guardrails: bounded parameter ranges + minimum sample sizes before retuning.

- [ ] Hold-time / exit discipline engine
  - Add explicit close/hedge/abandon logic before resolution when edge decays or risk rises.
  - Support time-stop and EV-stop exits for open paper/live positions.

- [ ] Auto dependency discovery (candidate rules + human approval)
  - Detect likely market-link constraints/correlations from text + historical co-movement.
  - Propose structural rules for review before activation (no blind auto-enable).

- [ ] Event-tree basket coverage (unlock `structural_event_tree`)
  - Build robust event-tree rule generation from real parent/child metadata (and fallback heuristics when explicit links are sparse).
  - Validate payout math and basket construction (`parent_no_children_yes`, `parent_yes_children_no`) against real market structures.
  - Add diagnostics for why event-tree opportunities are not emitted/opened (rule missing vs quote missing vs gating).
  - Run targeted paper experiments to measure incremental expected-realized and settled contribution from event-tree lane.

- [ ] Stream ingestion hardening (backpressure + recovery)
  - Add bounded per-venue queues with explicit backpressure/drop policy to avoid memory blowups under burst traffic.
  - Add stream health watchdogs (heartbeat lag, reconnect rate, message gap rate) with automatic degraded-mode handling.

- [ ] Delta/snapshot reconciliation loop
  - Periodically reconcile websocket state with REST snapshots to repair missed messages/out-of-order updates.
  - Track per-market checksum/version and force resync when divergence is detected.

- [ ] Deterministic dedupe + idempotency keys
  - Introduce stable opportunity IDs (kind + legs + execution style + time bucket) to prevent duplicate decisions/executions.
  - Enforce idempotent order intents across retries/reconnects.

- [ ] Market mapping QA pipeline
  - Validate cross-venue mapping cardinality (1:1 expectations), stale links, and semantic drift.
  - Auto-flag suspicious mappings using text/price-consistency checks before they can trade.

- [ ] Data-quality firewall
  - Reject/quarantine quotes with invalid prices/sizes, stale timestamps, or impossible bid/ask relationships.
  - Add anomaly guards for abrupt price jumps and missing-side books.

- [ ] Parallel lane execution architecture
  - Run lane detection in isolated workers/tasks with bounded fan-out and deterministic merge order.
  - Add per-lane timing metrics and timeout budgets so one lane cannot block the full cycle.

- [ ] Replay + deterministic simulation harness
  - Record raw stream/poll events and decisions, then replay deterministically for debugging/regression testing.
  - Support A/B profile replay on identical market data for fair tuning comparisons.

- [ ] Long-run storage + analytics pipeline
  - Persist quote/decision/position events to a queryable store (DuckDB/Parquet) with partitioning and retention policy.
  - Build daily summary jobs for lane-level conversion, fill-quality drift, and concentration risk.

- [ ] Execution realism upgrades (paper/live parity)
  - Simulate independent leg fill paths, queue position decay, and leg slippage instead of aggregate fill only.
  - Add adverse fill scenarios and partial-hedge penalties to reduce optimistic bias.

- [ ] Dynamic capacity controller
  - Adjust universe size, scoring depth, and scan cadence automatically based on CPU/memory/API/latency budgets.
  - Prefer highest value-per-compute markets during load spikes.

- [ ] Initialization speed + startup progress visibility
  - Reduce cold-start latency (parallelize market discovery/bootstrap, cache warm starts, and defer non-critical setup).
  - Emit explicit startup progress logs with timings per stage (config load, venue auth, market discovery, first quote readiness).
  - Add a startup timeout/fail-fast path so runs do not appear stuck with no output.

- [ ] Operational risk controls
  - Add global kill switch, venue kill switches, max daily loss, and max consecutive execution failure guardrails.
  - Add canary mode for new profiles (small capital slice + automatic rollback on KPI breach).

- [ ] Adaptive per-endpoint API rate governor (AIMD + token buckets)
  - Maintain independent budgets per venue and endpoint class (`markets`, `orderbook`, `events`, account/order endpoints).
  - Increase request rate gradually when healthy; cut quickly on `429`/timeouts and honor `Retry-After` automatically.
  - Operate near max safe throughput (target utilization band) instead of static pause/concurrency settings.

- [ ] Tiered polling scheduler for full-universe with minimum latency
  - Implement `hot` / `warm` / `cold` market tiers with different cadences (sub-second to minutes).
  - Promote markets to `hot` on stream updates, open positions, recent opportunities, or mapped cross/parity relevance.
  - Demote inactive markets automatically to preserve API budget for highest-EV symbols.

- [ ] Poll budget allocator + fairness controls
  - Allocate finite request budget across lanes (`intra`, `cross`, `bucket`, `parity`) and venues each cycle.
  - Prevent one lane/venue from starving the others under load.
  - Add strict ceilings and burst allowances per class so full-universe scans do not collapse real-time coverage.

- [ ] Cross/parity coverage watchdog with automatic repair
  - Track `cross_pairs_covered` and `parity_rules_covered` as hard health metrics.
  - Trigger targeted remap/reload/re-scan when coverage remains below thresholds for N cycles.
  - Fail fast (or alert loudly) if lane readiness is persistently zero while streams are nominal.

- [ ] Low-latency execution path optimization
  - Split detection and execution workers so order submission cannot block quote ingestion.
  - Pre-build and cache signed/authenticated request components where safe.
  - Measure and optimize `detect->plan->submit->ack` latency percentiles by venue.

- [ ] Confidence-scored strict mapping mode (reduce false positives without zeroing coverage)
  - Keep strict map IDs as primary, but allow a gated confidence fallback only when strict overlap is absent.
  - Require multi-signal agreement (text similarity + temporal overlap + price coherence) before fallback mapping is tradable.
  - Log fallback-origin opportunities separately for audit and rapid rollback.

## Primetime Readiness Checklist (Pass/Fail Gates)

- [ ] Identification quality benchmark (precision over volume)
  - Define an adjudication sample of detected opportunities by lane (`intra`, `cross/parity family`, `bucket`, `event_tree`).
  - PASS when false-positive rate stays below target and remains stable across at least 3 distinct sessions.

- [ ] Mapping integrity and drift checks
  - Track mapping confidence and drift alarms for strict map entries over time.
  - PASS when no high-severity mapping drift alerts persist for more than N cycles.

- [ ] Structural rule confidence labeling
  - Label rules as `exhaustive`, `non_exhaustive`, or `unknown`; price payouts from label instead of global assumption.
  - PASS when all high-notional structural buckets used for trading have explicit confidence labels.

- [ ] Quote sanity firewall hardening
  - Reject micro-price artifacts, stale/degenerate books, and impossible quote states before planning.
  - PASS when zero opened trades rely on rejected/invalid quote states in audit logs.

- [ ] Cross/parity family canonicalization and reporting
  - Keep dedupe to avoid double counting, but report family-level metrics so alias selection cannot hide lane behavior.
  - PASS when family totals reconcile exactly with opened trades and no duplicate family keys execute in same cooldown window.

- [ ] Fill and slippage calibration
  - Calibrate fill probability and slippage model against paper-forward realized outcomes (not just detected edge).
  - PASS when realized/expected ratio remains inside an agreed band for multi-hour runs.

- [ ] Execution-cost completeness
  - Include all venue-specific fees/frictions used in live mode in expected-realized calculation.
  - PASS when cost reconciliation vs venue statements shows no systematic underestimation.

- [ ] Outlier robustness in performance reporting
  - Always publish raw, micro-price-filtered, and top-outlier-removed KPIs.
  - PASS when strategy conclusions do not flip sign solely because of one outlier trade.

- [ ] Lane health SLOs
  - Monitor coverage/readiness and open-share by lane family with alert thresholds.
  - PASS when no lane remains unintentionally starved or zero-ready beyond allowed windows.

- [ ] Long-run stability test
  - Run multi-hour paper sessions with no manual intervention and no critical data/execution regressions.
  - PASS when uptime, coverage, and lane participation remain within thresholds for the full window.

- [ ] Live-forward canary protocol
  - Start with minimal notional and strict kill switches, then step capital only after gate pass.
  - PASS when each stage meets realized PnL, drawdown, and execution quality criteria.

## Sizing Improvements Backlog

- [ ] Tail-risk-aware Kelly sizing
  - Add uncertainty haircuts to edge inputs per lane/market family before Kelly fraction is computed.
  - Reduce effective Kelly when model error/variance increases.

- [ ] Liquidity impact curve integration
  - Replace static size assumptions with empirically learned slippage/impact curves vs notional.
  - Size down automatically when marginal impact erodes expected-realized edge.

- [ ] Dynamic per-lane bankroll allocation
  - Allocate bankroll adaptively across `intra`, `cross/parity`, `bucket`, `event_tree` using realized risk-adjusted efficiency.
  - Prevent persistent over-allocation to lanes with deteriorating realized performance.

- [ ] Confidence-scaled max-loss cap
  - Cap trade size by worst-case loss under model-error scenarios, not only expected edge.
  - Enforce tighter loss caps for low-confidence opportunities.

- [ ] Outlier-robust sizing inputs
  - Block or heavily downweight suspicious/micro-price quote states in sizing calculations.
  - Ensure one anomalous book snapshot cannot drive oversized positions.

- [ ] Time-to-resolution capital lock penalty
  - Apply explicit carry/lock-up penalty for long-duration positions in effective sizing.
  - Require higher edge to justify size on slower-resolving opportunities.

- [ ] Drawdown-adaptive de-risking
  - Auto-reduce global and per-lane sizing when rolling realized underperforms expected or drawdown thresholds trigger.
  - Restore size gradually only after recovery criteria are met.

## Risk Controls Backlog

- [ ] Pre-trade quote and mapping risk gates
  - Enforce strict quote sanity/staleness checks and mapping-confidence minimums before a trade can be planned.
  - Block trading on invalid/low-confidence states rather than allowing sizing to proceed.

- [ ] Legging risk controls (non-atomic execution)
  - Define max time window between first and second leg fills.
  - Implement cancel/unwind/hedge fallback policy when second leg misses or partial-fills outside tolerance.

- [ ] Exposure and concentration controls
  - Add hard caps by venue, market family, and correlation cluster.
  - Enforce max concurrent at-risk positions for each lane and family.

- [ ] Circuit breakers and auto-pause logic
  - Add daily loss cap, consecutive execution-failure cap, and data-health-triggered pause.
  - Require explicit recovery criteria before auto-resume.

- [ ] Lane readiness watchdog enforcement
  - Pause affected lanes when coverage/readiness stays below thresholds for N cycles.
  - Prevent degraded lanes from trading on partial/broken signal state.

- [ ] Expected-vs-realized drift monitoring
  - Track drift by lane/family and trigger de-risk mode when realized outcomes diverge from model expectations.
  - Add alerting and automatic throttle-down on sustained negative drift.

- [ ] Operational failure handling playbooks
  - Codify runbook behavior for 429 storms, stream disconnect loops, and venue-specific outages.
  - Ensure deterministic fail-safe behavior instead of continuing with stale/incomplete inputs.

## Primetime Workstreams (Explicit)

- [ ] Execution quality
  - Improve realistic fill behavior, queue position modeling, cancel/replace logic, and partial-leg risk handling.

- [ ] Cost realism
  - Complete fee/friction accounting per venue and order type.
  - Continuously reconcile modeled costs to realized fills.

- [ ] Risk controls
  - Implement hard kill switches, daily drawdown stops, venue/lane shutdown logic, and automatic de-risk mode.

- [ ] Data quality + integrity
  - Enforce strong quote firewall, stale/malformed-state rejection, stream/snapshot reconciliation, and gap recovery.

- [ ] Reliability/operations
  - Build health checks, alerting, retry policies, rate-limit governance, and degraded-venue recovery.

- [ ] Performance measurement discipline
  - Standardize KPI stack: raw vs filtered vs outlier-removed, detected vs expected-realized vs realized, and lane-family attribution.

- [ ] Live-forward deployment process
  - Use canary capital stages with objective promotion criteria and rollback rules.

## Execution Plan (Backlog Order)

- [ ] Phase 1: Data correctness and measurement baseline (Week 1)
  - Scope: Data quality + integrity, performance measurement discipline, cross/parity family reporting.
  - Key outputs: quote firewall enabled, stream/snapshot reconciliation checks, standardized KPI report (raw/filtered/outlier-removed, detected vs expected-realized vs realized, lane-family attribution).
  - Exit gate: zero invalid-quote opens in audit sample and reproducible KPI report for every paper run.

- [ ] Phase 2: Identification hardening (Week 2)
  - Scope: mapping integrity/drift checks, structural rule confidence labels (`exhaustive`/`non_exhaustive`/`unknown`), strict mapping confidence fallback.
  - Key outputs: mapping QA pipeline, structural confidence labels on active rules, precision benchmark by lane.
  - Exit gate: false-positive rate within target band and no unresolved high-severity mapping drift alerts.

- [ ] Phase 3: Execution and cost realism (Week 3)
  - Scope: execution quality + cost realism.
  - Key outputs: improved fill/queue/partial-leg model, cancel/replace policy, complete fee/friction accounting reconciled to realized fills.
  - Exit gate: realized/expected ratio in target band on multi-hour paper sessions after outlier controls.

- [ ] Phase 4: Risk control framework (Week 4)
  - Scope: risk controls + sizing safety overlays.
  - Key outputs: kill switches, daily drawdown stop, lane/venue shutdown rules, legging controls, drawdown-adaptive sizing, confidence-scaled loss caps.
  - Exit gate: fault-injection tests trigger the expected pause/de-risk behavior with deterministic recovery.

- [ ] Phase 5: Reliability and scale stability (Week 5)
  - Scope: reliability/operations for long unattended runs.
  - Key outputs: health checks + alerting, adaptive rate governor, tiered polling scheduler, runbooks for degraded venue states.
  - Exit gate: long-run paper stability target met (coverage, lane participation, and no critical outages for full test window).

- [ ] Phase 6: Live-forward canary rollout (Week 6+)
  - Scope: controlled production validation.
  - Key outputs: staged notional ramp with hard rollback criteria and objective promotion gates.
  - Exit gate: each stage passes realized PnL quality, drawdown, and execution reliability thresholds before capital increase.

## Immediate Plan (Next 72 Hours)

- [ ] Day 1: Stabilize signal integrity
  - Implement lane-family accounting so `cross_venue` and `structural_parity` share one canonical family key in KPI output (no double counting, no hidden suppression).
  - Lock strict quote-quality gates before planning/sizing and record explicit reject reasons.
  - Deliverable: one 2-4h paper run where family totals reconcile exactly with opened rows.

- [ ] Day 1: Confirm full-universe coverage behavior
  - Run hybrid mode with adaptive polling budgets and lane fairness controls enabled.
  - Record coverage SLOs every cycle (`cross_pairs_covered`, `parity_rules_covered`, lane-ready flags).
  - Deliverable: no persistent unintended lane starvation window longer than threshold.

- [ ] Day 2: Execution realism + costs
  - Add/verify partial-leg penalties, queue-aware fill probability checks, and complete fee/friction accounting.
  - Publish side-by-side KPI table (`detected`, `expected_realized`, `simulated_realized`) with outlier-removed view.
  - Deliverable: realized/expected ratio in target band on at least one multi-hour paper run.

- [ ] Day 2: Sizing safety overlays
  - Add confidence-scaled size haircut and drawdown-adaptive de-risk multiplier around current Kelly sizing.
  - Add explicit time-to-resolution lock-up penalty in effective edge.
  - Deliverable: no outsized positions from low-confidence or micro-price inputs.

- [ ] Day 3: Reliability hardening
  - Add lane-readiness watchdog actions (auto-pause/throttle affected lane, alert reason).
  - Add 429/degraded-venue runbook automation and deterministic recovery checks.
  - Deliverable: unattended 6h+ paper run with stable coverage and no critical recovery failures.

- [ ] Day 3: Go/No-Go packet for canary live-forward
  - Produce one decision report: KPI summary, failure budget consumed, open risks, recommended canary notional.
  - Deliverable: explicit promotion criteria and rollback triggers for Stage 1 live-forward.

- [ ] Day 3: Rust migration prep (pre-live)
  - Define hot-path modules to port first (`opportunity scan`, `quote normalization`, `sizing/eval`) and lock Pythonâ†”Rust parity tests.
  - Produce phased cutover plan (FFI/service boundary, benchmarks, rollback path) with no strategy logic drift.
  - Deliverable: approved migration design doc + parity benchmark harness ready before live-capital scaling.

## Accelerated Plan (5-Day Fast Track)

- [x] Day 0 (Today): Signal correctness lock
  - Finalize lane-family accounting (`cross_venue` + `structural_parity` family reconciliation).
  - Enforce quote-quality gating with explicit reject-reason telemetry.
  - Exit: family totals exactly match opened rows; no invalid-quote opens.

- [ ] Day 1: Full-universe coverage stability
  - Run hybrid poll/stream with lane fairness and coverage watchdogs.
  - Tune per-venue/per-endpoint polling budgets to avoid starvation.
  - Exit: `cross_pairs_covered` and `parity_rules_covered` remain non-zero and stable for multi-hour paper run.

- [ ] Day 2: Execution realism and cost realism
  - Tighten fill/queue/partial-leg assumptions and complete fee/friction accounting.
  - Publish KPI set: raw vs filtered vs outlier-removed; detected vs expected-realized vs simulated-realized.
  - Exit: expected/realized gap inside agreed tolerance band.

- [ ] Day 3: Risk and safety hardening
  - Add hard kill switches, lane auto-pause on degraded readiness, drawdown-based de-risk mode.
  - Add deterministic recovery actions for 429/degraded venue states.
  - Exit: fault-injection checks pass for pause/resume/de-risk behavior.

- [ ] Day 4: Long-run validation + canary decision
  - Run unattended long paper session with full-universe config.
  - Produce promotion packet (go/no-go, rollback triggers, initial canary capital).
  - Exit: all critical gates green for Stage-1 live-forward.

- [ ] Day 4: Rust refactor plan lock-in
  - Finalize staged Rust rollout plan and performance SLOs (latency, throughput, CPU/memory) for pre-live readiness.
  - Exit: implementation-ready backlog with module order, parity gates, and measurable performance targets.

- [ ] Deferred (after fast track)
  - Advanced auto-tuning loops, broader event-tree automation, and capacity optimizations beyond immediate reliability/signal goals.
  - Plan and execute a staged Rust refactor (hot-path first) for pre-live latency/throughput gains while preserving Python parity tests and rollout safety gates.

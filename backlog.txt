# Consolidated Master Plan: Dry-Run to Live Trading Readiness

## Context

The arb bot has mature detection, sizing, and paper simulation, but critical gaps in post-execution lifecycle (order tracking, crash recovery, legging safety), operational controls (kill switches, circuit breakers), and execution latency (Python too slow for live edge capture) make it unsafe for real money. This plan consolidates **all 59 existing backlog items** plus **6 new items** identified during code review into a single dependency-ordered, safety-first roadmap. The Rust hot-path migration is a prerequisite for live trading — Python latency cannot capture real edge on live markets.

Every item from the original backlog appears exactly once in the cross-reference table at the bottom.

---

## PHASE 0: Crash Safety and Order Lifecycle (Week 1-2)

**Why first:** A crash between leg A filling and leg B submitting leaves an unhedged position with no record. This is the #1 capital-loss risk.

### 0A. Persistent order/position store (SQLite) — [NEW 60]
- New module `arb_bot/order_store.py` with SQLite-backed `order_intents` and `positions` tables
- Write intent row BEFORE calling `place_single_order()`, update on response
- Back `EngineState` in-memory dicts (`cash_by_venue`, `locked_capital_by_venue`, `open_markets_by_venue`) from store on startup

### 0B. Legging risk controls — [Backlog 32]
- Execute cross-venue legs sequentially (not `asyncio.gather`) in `_execute_live_plan` (engine.py:2112)
- After leg A fills: re-check leg B quote freshness, abort + cancel leg A if book moved beyond tolerance
- Max time window between leg fills (config param), cancel/unwind/hedge fallback on miss

### 0C. Cancel/replace for unfilled legs — [NEW 65]
- Add `cancel_order()` and `get_order_status()` to `ExchangeAdapter` ABC (exchanges/base.py)
- Implement for Kalshi (10s expiry needs re-submit logic) and Polymarket

### 0D. Post-submission order status polling — [NEW 63]
- Poll order status after placement to verify fills, update persistent store
- Timeout triggers cancel/unwind policy from 0B

### 0E. Partial fill handling — [NEW 64]
- Track per-leg fill state in persistent store
- Compute hedged vs exposed portion, decide close/wait for exposed remainder

### 0F. Crash recovery startup — [NEW 61]
- On boot: read persistent store, reconcile against exchange account/position APIs
- Unhedged positions discovered → safe mode (no new trades until operator acknowledges)

### 0G. Automatic balance refresh — [NEW 62]
- Periodic venue balance refresh on timer (default 60s) instead of only at `run_once` start
- Auto-release stale locked capital by reconciling against exchange balance

**Exit gate:** Crash mid-execution recovers to correct state on reboot. Leg-A-fills/leg-B-fails triggers cancel and store reflects correct state. All existing tests pass.

---

## PHASE 1: Kill Switches and Circuit Breakers (Week 2-3)

**Why second:** With persistent state, we need the ability to halt the bot before it loses more money.

### 1A. Operational risk controls — [Backlog 17]
- Global kill switch (file/env), per-venue kill switch, daily loss cap, max consecutive failures, canary mode

### 1B. Circuit breakers and auto-pause — [Backlog 34]
- Data-health-triggered pause, explicit recovery criteria before auto-resume

### 1C. Endpoint-specific circuit breakers — [Backlog 41]
- Independent per-endpoint circuits (kalshi `/markets`, `/events`, `/orderbook`; polymarket book), jittered probe recovery

### 1D. Automatic mode degradation with hysteresis — [Backlog 39]
- Deterministic failover: stream → hybrid → poll-only, hysteresis to prevent flapping

### 1E. Pre-run hard gate wrapper — [Backlog 38]
- Startup gate chain (stream preflight + dual-venue smoke + phase0 mini-gate), abort if red

### 1F. Process supervision policy — [Backlog 46]
- launchd/systemd/container config, crash-loop detection, safe-stop, restart invokes crash recovery (0F)

**Exit gate:** Kill switch halts orders within 1 cycle. Daily loss cap triggers halt before threshold. Circuit breaker opens on simulated 429 storm and recovers.

---

## PHASE 2: Data Quality and Measurement Baseline (Week 3-4)

**Why third:** Before optimizing, we need trustworthy signals and trustworthy measurement.

### 2A. Pre-trade quote and mapping risk gates — [Backlog 31]
- Strict quote sanity/staleness checks and mapping-confidence minimums before planning

### 2B. Quote sanity firewall hardening — [Backlog 51 / Gate]
- Reject micro-price artifacts, stale/degenerate books, impossible quote states, price jump anomaly guards

### 2C. Delta/snapshot reconciliation loop — [Backlog 8]
- Periodic REST snapshot vs WebSocket state reconciliation, per-market checksum/version, force resync on divergence

### 2D. Stream ingestion hardening — [Backlog 7]
- Bounded per-venue queues with backpressure/drop policy, stream health watchdogs (heartbeat lag, reconnect rate, gap rate)

### 2E. Deterministic dedupe + idempotency keys — [Backlog 9]
- Stable opportunity IDs (kind + legs + style + time bucket), idempotent order intents via persistent store

### 2F. Market mapping QA pipeline — [Backlog 10]
- Validate mapping cardinality, stale links, semantic drift; auto-flag suspicious mappings

### 2G. Long-run storage + analytics pipeline — [Backlog 13]
- DuckDB/Parquet store with partitioning and retention, daily summary jobs (lane conversion, fill-quality drift, concentration)

### 2H. Metrics export + alert dashboard — [Backlog 44]
- Prometheus/StatsD export (coverage, readiness, skip-reason, 429, reconnect), alert thresholds, pager signals

**Exit gate:** Zero invalid-quote opens in audit sample. Stream/snapshot reconciliation corrects injected drift within 2 refresh cycles. Reproducible KPI report for every paper run. DuckDB queryable for daily summaries.

**Primetime gates achievable:** Identification quality benchmark [48], Mapping integrity [49], Structural rule confidence labeling [50], Quote sanity firewall [51], Cross/parity family canonicalization [52]

---

## PHASE 3: Execution Quality and Cost Realism (Week 4-5)

**Why fourth:** With reliable data, improve execution modeling so paper results predict live results.

### 3A. Execution realism upgrades — [Backlog 14]
- Independent leg fill paths, queue position decay, leg slippage (replace scalar fill model in engine.py:2154)

### 3B. Fill and slippage calibration — [Backlog 53 / Gate]
- Calibrate fill/slippage model against paper-forward realized outcomes using DuckDB store

### 3C. Execution-cost completeness — [Backlog 54 / Gate]
- Complete fee/friction accounting per venue and order type, reconcile vs venue statements

### 3D. Maker-first live execution policy — [Backlog 1]
- Passive entry when queue/fill model implies positive EV net of adverse selection, taker fallback

### 3E. Latency SLO + auto-throttle — [Backlog 2]
- First-class SLOs for quote age / decision latency / execution latency, auto-throttle on persistent breaches

### 3F. Low-latency execution path optimization — [Backlog 22]
- Split detection and execution workers, pre-build signed request components, measure detect-to-ack p95

**Exit gate:** Realized/expected ratio inside target band on multi-hour paper. Cost reconciliation shows no systematic underestimation. Latency p95 measured and below threshold.

**Primetime gates achievable:** Fill and slippage calibration [53], Execution-cost completeness [54]

---

## PHASE 4: Sizing Safety and Risk Framework (Week 5-6)

**Why fifth:** Accurate execution modeling is a prerequisite for reliable sizing and risk controls.

### 4A. Tail-risk-aware Kelly sizing — [Backlog 24]
- Uncertainty haircuts per lane/family, reduce Kelly when model error/variance increases (sizing.py)

### 4B. Liquidity impact curve integration — [Backlog 25]
- Empirically learned slippage/impact curves, auto size-down when marginal impact erodes edge

### 4C. Confidence-scaled max-loss cap — [Backlog 27]
- Worst-case loss cap under model-error scenarios, tighter caps for low-confidence opportunities

### 4D. Outlier-robust sizing inputs — [Backlog 28]
- Block/downweight suspicious quote states in sizing, prevent anomalous books from driving oversized positions

### 4E. Time-to-resolution capital lock penalty — [Backlog 29]
- Carry/lock-up penalty for long-duration positions, require higher edge for slower-resolving opportunities

### 4F. Drawdown-adaptive de-risking — [Backlog 30]
- Auto-reduce sizing when rolling realized underperforms expected, restore gradually after recovery criteria met

### 4G. Dynamic per-lane bankroll allocation — [Backlog 26]
- Adaptive allocation across lanes by realized risk-adjusted efficiency, prevent over-allocation to deteriorating lanes

### 4H. Exposure and concentration controls — [Backlog 33]
- Hard caps by venue, market family, and correlation cluster; max concurrent at-risk positions per lane/family (risk.py)

### 4I. Expected-vs-realized drift monitoring — [Backlog 36]
- Track drift by lane/family, trigger de-risk mode on sustained negative drift, alerting + auto throttle-down

### 4J. Lane readiness watchdog enforcement — [Backlog 35]
- Auto-pause lanes below coverage/readiness thresholds, prevent trading on partial/broken signal state

**Exit gate:** Fault-injection triggers expected de-risk behavior. No outsized positions from low-confidence inputs in 24h paper run. Drawdown-adaptive sizing reduces exposure during simulated drawdown.

**Primetime gates achievable:** Outlier robustness in reporting [55]

---

## PHASE 5: Reliability and Operational Readiness (Week 6-7)

**Why sixth:** All safety systems in place; now harden for unattended multi-hour/multi-day operation.

### 5A. Adaptive per-endpoint API rate governor — [Backlog 18]
- AIMD + token buckets per venue/endpoint, Retry-After parsing (replace basic `_endpoint_next_request_ts` in kalshi.py)

### 5B. Tiered polling scheduler — [Backlog 19]
- Hot/warm/cold tiers (sub-second to minutes), promote on stream updates/positions/opportunities, auto-demote inactive

### 5C. Poll budget allocator + fairness — [Backlog 20]
- Budget across lanes/venues per cycle, prevent starvation, strict ceilings + burst allowances

### 5D. Cross/parity coverage watchdog — [Backlog 21]
- Track `cross_pairs_covered` / `parity_rules_covered` as health metrics, targeted repair on threshold breach

### 5E. Cross/parity keepalive probe set — [Backlog 42]
- Low-rate probes for mapped pairs/rules, alert on coverage floor breach

### 5F. Dual-venue bootstrap budget enforcement — [Backlog 40]
- Reserve startup API budget for mapped overlap symbols, prevent one-venue starvation

### 5G. Persistent warm-cache snapshots — [Backlog 43]
- Persist quote cache + coverage state, reload at startup, reduce time-to-readiness after restarts

### 5H. Initialization speed + startup progress — [Backlog 16]
- Parallelize discovery/bootstrap, cache warm starts, startup progress logs with timings, timeout/fail-fast path

### 5I. Parallel lane execution architecture — [Backlog 11]
- Isolated lane workers with bounded fan-out, deterministic merge, per-lane timing metrics + timeout budgets

### 5J. Dynamic capacity controller — [Backlog 15]
- Auto-adjust universe size/scoring depth/scan cadence by CPU/memory/API/latency budgets

### 5K. Operational failure handling playbooks — [Backlog 37]
- Codified runbooks for 429 storms, stream disconnect loops, venue outages; deterministic fail-safe behavior

### 5L. Secret and credential hardening — [Backlog 45]
- OS keychain/secret manager, key-scope/expiry validation, rotation runbook

### 5M. Incident replay bundle automation — [Backlog 47]
- One-command export of run artifacts (logs, config, coverage, decisions), consumable by replay harness

### 5N. Replay + deterministic simulation harness — [Backlog 12]
- Record raw stream/poll events + decisions, deterministic replay, A/B profile replay on identical data

**Exit gate:** 8+ hour paper session with stable coverage and no critical regressions. Rate governor backs off on 429 storms and recovers. Cold start time below target.

**Primetime gates achievable:** Lane health SLOs [56], Long-run stability test [57]

---

## PHASE 6: Signal Intelligence and Strategy Upgrades (Week 7-8)

**Note:** Phase 6 and Phase 7 (Rust migration) can proceed in parallel if resources allow, since they have no dependencies on each other. Both must complete before Phase 8 (live canary).

**Why seventh:** System is safe and reliable; now improve signal quality and strategy sophistication.

### 6A. Confidence-scored strict mapping mode — [Backlog 23]
- Strict map primary, gated confidence fallback with multi-signal agreement, separate audit logging

### 6B. Event-tree basket coverage — [Backlog 6]
- Robust rule generation from real parent/child metadata, payout math validation, diagnostics, paper experiments

### 6C. Auto dependency discovery — [Backlog 5]
- Detect likely market-link constraints from text + co-movement, propose rules for human review

### 6D. Hold-time / exit discipline engine — [Backlog 4]
- Close/hedge/abandon logic on edge decay or risk rise, time-stop and EV-stop exits

### 6E. KPI-driven auto-tuning loop — [Backlog 3]
- Periodic threshold adjustment from paper KPIs, bounded parameter ranges, minimum sample sizes

**Exit gate:** Event-tree lane contributes non-trivially to paper PnL across 2+ multi-hour sessions. Auto-tuning produces no degenerate parameters in 48h run.

---

## PHASE 7: Rust Migration (Week 8-10)

**Why before live:** Python is too slow to capture real edge on live markets. The hot-path latency improvement from Rust is essential for any live trading to be profitable. This must be complete before canary deployment.

### 7A. Migration design and parity harness — [Backlog 59]
- Define hot-path modules to port first: opportunity scan, quote normalization, sizing/eval
- Lock Python-to-Rust parity tests: identical inputs must produce identical outputs across both implementations
- Design FFI/service boundary (PyO3 extension module vs separate process with IPC)
- Establish performance SLOs: latency targets (detect-to-plan p95/p99), throughput (quotes/sec), CPU/memory budgets

### 7B. Hot-path implementation
- Port quote normalization and binary math (highest call frequency, simplest logic)
- Port opportunity detection (5 lanes — largest latency contributor)
- Port sizing/eval (Kelly, fill model, ranking)
- Each module: implement in Rust, validate parity, benchmark vs Python baseline

### 7C. Integration and cutover
- Wire Rust modules into Python engine via chosen boundary (PyO3 recommended for lowest-latency path)
- Run parallel Python + Rust execution in paper mode, compare outputs for drift
- Staged cutover: one module at a time, rollback path for each
- Final benchmark: full cycle latency end-to-end must meet SLOs

**Exit gate:** All hot-path modules ported. Parity tests pass. Latency SLOs met. Multi-hour paper session with Rust hot path shows no regression vs Python-only baseline in detection quality.

---

## PHASE 8: Live-Forward Canary Rollout (Week 10+)

**Why last:** All phases including Rust migration must pass before live capital.

### 8A. Live-forward canary protocol — [Backlog 58 / Gate]
- **Stage 1:** $25-50, kill switches armed, 1-2 lanes (intra-venue + one cross-venue pair)
- **Stage 2:** $100-200, all lanes, 48h minimum
- **Stage 3:** Scale to target notional after gate pass

### 8B. Primetime readiness gate evaluation
- Run full gate checklist before Stage 1, re-run between each stage promotion

**Exit gate:** Each stage passes realized PnL, drawdown, execution reliability thresholds. Zero unacknowledged unhedged positions. Rust hot path running in production.

---

## PRIMETIME READINESS GATES

All must be green before Phase 8 Stage 1.

| Gate | Phase |
|------|-------|
| Identification quality benchmark [48] | 2 |
| Mapping integrity and drift checks [49] | 2 |
| Structural rule confidence labeling [50] | 2 |
| Quote sanity firewall hardening [51] | 2 |
| Cross/parity family canonicalization [52] | 2 |
| Fill and slippage calibration [53] | 3 |
| Execution-cost completeness [54] | 3 |
| Outlier robustness in reporting [55] | 4 |
| Lane health SLOs [56] | 5 |
| Long-run stability test [57] | 5 |
| Rust hot-path latency SLOs [59] | 7 |
| Live-forward canary protocol [58] | 8 |

---

## ITEM-TO-PHASE CROSS-REFERENCE

| # | Item | Phase |
|---|------|-------|
| 1 | Maker-first live execution policy | 3D |
| 2 | Latency SLO + auto-throttle | 3E |
| 3 | KPI-driven auto-tuning loop | 6E |
| 4 | Hold-time / exit discipline engine | 6D |
| 5 | Auto dependency discovery | 6C |
| 6 | Event-tree basket coverage | 6B |
| 7 | Stream ingestion hardening | 2D |
| 8 | Delta/snapshot reconciliation | 2C |
| 9 | Deterministic dedupe + idempotency | 2E |
| 10 | Market mapping QA pipeline | 2F |
| 11 | Parallel lane execution | 5I |
| 12 | Replay + simulation harness | 5N |
| 13 | Long-run storage + analytics | 2G |
| 14 | Execution realism upgrades | 3A |
| 15 | Dynamic capacity controller | 5J |
| 16 | Initialization speed + startup | 5H |
| 17 | Operational risk controls | 1A |
| 18 | Adaptive API rate governor | 5A |
| 19 | Tiered polling scheduler | 5B |
| 20 | Poll budget allocator + fairness | 5C |
| 21 | Cross/parity coverage watchdog | 5D |
| 22 | Low-latency execution path | 3F |
| 23 | Confidence-scored strict mapping | 6A |
| 24 | Tail-risk-aware Kelly sizing | 4A |
| 25 | Liquidity impact curve | 4B |
| 26 | Dynamic per-lane bankroll | 4G |
| 27 | Confidence-scaled max-loss cap | 4C |
| 28 | Outlier-robust sizing inputs | 4D |
| 29 | Time-to-resolution lock penalty | 4E |
| 30 | Drawdown-adaptive de-risking | 4F |
| 31 | Pre-trade quote/mapping gates | 2A |
| 32 | Legging risk controls | 0B |
| 33 | Exposure + concentration controls | 4H |
| 34 | Circuit breakers + auto-pause | 1B |
| 35 | Lane readiness watchdog | 4J |
| 36 | Expected-vs-realized drift | 4I |
| 37 | Operational failure playbooks | 5K |
| 38 | Pre-run hard gate wrapper | 1E |
| 39 | Auto mode degradation + hysteresis | 1D |
| 40 | Dual-venue bootstrap budget | 5F |
| 41 | Endpoint-specific circuit breakers | 1C |
| 42 | Cross/parity keepalive probes | 5E |
| 43 | Persistent warm-cache snapshots | 5G |
| 44 | Metrics export + alert dashboard | 2H |
| 45 | Secret + credential hardening | 5L |
| 46 | Process supervision policy | 1F |
| 47 | Incident replay bundle | 5M |
| 48 | Identification quality gate | Primetime/2 |
| 49 | Mapping integrity gate | Primetime/2 |
| 50 | Structural rule confidence gate | Primetime/2 |
| 51 | Quote sanity firewall gate | Primetime/2 |
| 52 | Cross/parity family gate | Primetime/2 |
| 53 | Fill + slippage calibration gate | Primetime/3 |
| 54 | Execution-cost completeness gate | Primetime/3 |
| 55 | Outlier robustness gate | Primetime/4 |
| 56 | Lane health SLOs gate | Primetime/5 |
| 57 | Long-run stability gate | Primetime/5 |
| 58 | Live-forward canary gate | Primetime/8 |
| 59 | Rust migration (hot-path port) | 7A-7C |
| 60 | Persistent order/position store | 0A |
| 61 | Crash recovery startup | 0F |
| 62 | Automatic balance refresh | 0G |
| 63 | Post-submission order status polling | 0D |
| 64 | Partial fill handling | 0E |
| 65 | Cancel/replace for unfilled legs | 0C |
| 66 | Crypto: disable up/down markets | C0A |
| 67 | Crypto: per-underlying position cap | C0B |
| 68 | Crypto: higher min edge for daily | C0C |
| 69 | Crypto: model uncertainty multiplier | C0D |
| 70 | Crypto: parse is_buyer_maker | C1A |
| 71 | Crypto: OFI computation | C1B |
| 72 | Crypto: volume flow rate | C1C |
| 73 | Crypto: OFI calibrator | C1D |
| 74 | Crypto: wire OFI drift into engine | C1E |
| 75 | Crypto: historical aggTrades bootstrap | C1F |
| 76 | Crypto: rolling OFI recalibration | C1G |
| 77 | Crypto: activity-scaled volatility | C2A |
| 78 | Crypto: full volume clock (SBM) | C3A-B |
| 79 | Crypto: Hawkes self-exciting vol | C4A-B |
| 80 | Crypto: bootstrap vol uncertainty | C5A |
| 81 | Crypto: Bayesian posterior CI | C5B |

---

## KEY FILES

- `arb_bot/engine.py` — Core engine, `_execute_live_plan` (line 2069), in-memory state management
- `arb_bot/exchanges/base.py` — ExchangeAdapter ABC (needs `cancel_order`, `get_order_status`, `get_positions`)
- `arb_bot/exchanges/kalshi.py` — Kalshi API + WebSocket (order placement line 1678, auth line 1746)
- `arb_bot/exchanges/polymarket.py` — Polymarket API + WebSocket (order placement line 777)
- `arb_bot/risk.py` — RiskManager `precheck` and `record_fill` (needs kill switches, daily loss, concentration)
- `arb_bot/sizing.py` — PositionSizer `execution_aware_kelly_fraction` (line 127, needs Phase 4 modifications)
- `arb_bot/models.py` — EngineState (line 201), execution result types (needs persistent state extension)
- `arb_bot/paper.py` — Paper simulation (needs Phase 3 execution realism upgrades)
- `arb_bot/config.py` — Configuration (needs new params for all phases)
- `arb_bot/order_store.py` — NEW: persistent SQLite store (Phase 0)

---

## POST-PHASE BACKLOG (Identified During Paper Run Validation)

### B1. Cross-venue mapping semantic verification pipeline
- Current cross_venue_map generator matches markets by name/text similarity only
- Does NOT verify both sides ask the same question (e.g., "will X run?" vs "will X win?")
- KX2028RRUN mapping bug inflated paper PnL by 81% — detected 65¢ "edges" that were just the difference between probability of running vs winning
- **Architecture: LLM-as-offline-curator (NOT in the hot path)**
  - Separate process runs parallel to the bot, periodically (e.g., every 15-30 min)
  - Fetches market titles, descriptions, and resolution criteria from both venues
  - Uses LLM to semantically compare each candidate pair: same question? same resolution? same time horizon?
  - Outputs a confirmed-matches CSV with confidence scores and rejection reasons
  - Bot reads the confirmed-matches file on startup and via hot-reload when updated
  - LLM latency (~1-5s per pair) is acceptable offline but NOT in the detection/execution loop
- Pipeline stages:
  1. Text-similarity candidate generation (current approach — fast, high recall, low precision)
  2. LLM semantic verification (new — slower, high precision, filters false positives)
  3. Price correlation validation (optional — truly equivalent markets should co-move)
  4. Output: `cross_venue_map.verified.csv` with only LLM-confirmed matches
- Runtime safety: bot also applies a max-edge-per-contract sanity gate (e.g., reject cross-venue edges >30% as likely mapping errors)
- Related: runtime price-sum sanity check already added for structural buckets (_BUCKET_PRICE_SUM_MIN=0.70)

### B2. Monte Carlo execution simulation for paper runs
- Current paper mode books `expected_realized_profit` as actual PnL for every trade — this is an expected value, not a simulated outcome
- Result: 100% win rate across 1000+ trades, which is unrealistic
- Need: Monte Carlo settlement that randomly simulates per-trade outcomes:
  - Fill/no-fill for each leg (using fill_probability per leg, not just combined)
  - Legging risk: leg 1 fills but leg 2 doesn't → exposed position with loss
  - Adverse selection: filled orders have worse-than-expected outcomes (price moved against us)
  - Slippage: actual fill price differs from quoted price
  - Execution latency: edge decay between detection and fill
- Should produce realistic PnL distributions with wins AND losses
- Key metric: what % of the expected-value PnL actually converts to realized PnL?

---

## CRYPTO MODULE UPGRADES (Identified During 1-Hour Paper Test Sanity Check)

**Context:** 1-hour paper test (Feb 14 2026) showed -$108.94 PnL on $500 bankroll. Root causes: zero-drift GBM has no directional signal, 15-min up/down markets are pure coinflips, correlated positions across strikes, uncertainty estimates are artificially tight. See `docs/plans/2026-02-14-crypto-microstructure-upgrade.md` for full implementation plan.

### C0. Tier 0 — Risk Control Fixes (Immediate)
- **C0A.** Disable 15-min up/down markets — model outputs 50% for all of them (zero drift GBM is symmetric). Re-enable only after OFI drift is live.
  - Config: `allowed_directions: List[str] = ["above", "below"]`
  - Files: `arb_bot/crypto/config.py`, `arb_bot/crypto/engine.py`
- **C0B.** Per-underlying position correlation cap — max 3 simultaneous positions per underlying (BTC, SOL, etc.) at different strikes. Paper test had 7 correlated BTC positions that all lost together.
  - Config: `max_positions_per_underlying: int = 3`
  - Files: `arb_bot/crypto/config.py`, `arb_bot/crypto/engine.py`
- **C0C.** Higher min edge for daily markets — raise from 3% to 6% for above/below markets (>30 min TTE). 3-4% edges were noise.
  - Config: `min_edge_pct_daily: float = 0.06`
  - Files: `arb_bot/crypto/config.py`, `arb_bot/crypto/edge_detector.py`
- **C0D.** Model uncertainty multiplier — multiply Wilson CI half-width by 3x to reflect vol estimation uncertainty (not just MC sampling error). This feeds through to Baker-McHale shrinkage for smaller position sizes.
  - Config: `model_uncertainty_multiplier: float = 3.0`
  - Files: `arb_bot/crypto/config.py`, `arb_bot/crypto/engine.py`

### C1. Tier 1 — OFI Directional Signal (Short Term)
- **C1A.** Parse `is_buyer_maker` from Binance WS trade stream. Track buy vs sell volume per symbol.
  - Files: `arb_bot/crypto/price_feed.py` (extend `PriceTick`, `_handle_message`)
- **C1B.** Expose `get_ofi(symbol, window_seconds)` returning Order Flow Imbalance in [-1, +1].
  - OFI = (buy_vol - sell_vol) / (buy_vol + sell_vol)
  - Files: `arb_bot/crypto/price_feed.py`
- **C1C.** Volume flow rate tracking — `get_volume_flow_rate(symbol, window_seconds)` for activity scaling.
  - Files: `arb_bot/crypto/price_feed.py`
- **C1D.** OFI calibrator — rolling OLS regression of OFI against 5-min forward returns. Fit alpha coefficient with R² gating (alpha=0 if signal is noise).
  - New module: `arb_bot/crypto/ofi_calibrator.py`
  - Config: `ofi_recalibrate_interval_hours: float = 4.0`
- **C1E.** Wire OFI drift into engine — replace `drift = 0.0` with `drift = alpha * ofi`. Alpha starts at 0 and self-calibrates.
  - Config: `ofi_enabled: bool = True`, `ofi_window_seconds: int = 300`
  - Files: `arb_bot/crypto/engine.py:415`
- **C1F.** Historical aggTrades bootstrap — fetch 48h of Binance aggTrades REST data for initial OFI alpha calibration on first run (no 24h wait required).
  - Files: `arb_bot/crypto/price_feed.py` (add `load_historical_trades`)
- **C1G.** Rolling OFI recalibration — refit alpha every N hours on trailing window. If R² drops below threshold, reduce alpha toward 0 (regime guard).
  - Files: `arb_bot/crypto/engine.py`, `arb_bot/crypto/ofi_calibrator.py`
- **References:** Cont, Kukanov & Stoikov (2014) "The Price Impact of Order Book Events"

### C2. Tier 2 Lite — Activity-Scaled Volatility (Short Term)
- **C2A.** Activity-scaled vol — multiply volatility by `sqrt(current_volume_rate / avg_volume_rate)`, clamped to [0.25, 4.0]. Automatically "speeds up" vol during crashes and "slows down" during low-volume chop.
  - Config: `activity_scaling_enabled: bool = True`, `activity_scaling_short_window_seconds: int = 300`, `activity_scaling_long_window_seconds: int = 3600`
  - Files: `arb_bot/crypto/engine.py`, `arb_bot/crypto/price_feed.py`
- **References:** Clark (1973) "A Subordinated Stochastic Process Model with Finite Variance for Speculative Prices"

### C3. Tier 2 Full — Volume Clock (Medium Term, Future)
- **C3A.** Full Subordinated Brownian Motion — replace `dt = horizon_minutes / MINUTES_PER_YEAR` with volume-based time. Requires rederiving drift terms, jump intensity (per-volume instead of per-time), and removing BS analytical crosscheck (N(d2) assumes clock-time GBM).
  - Depends on: C2A proving value via paper tests
  - Files: `arb_bot/crypto/price_model.py`, `arb_bot/crypto/engine.py`
- **C3B.** Volume path generation — stochastic volume forecasting for non-linear time-to-expiry modeling. Volume rate itself is predictable (US hours vs 3AM UTC, liquidation cascades).
  - Files: `arb_bot/crypto/price_model.py`

### C4. Tier 2 Full — Hawkes Self-Exciting Volatility (Medium Term, Future)
- **C4A.** Hawkes process intensity tracker — track "tick outliers" (returns > 3σ), model intensity λ(t) = baseline + Σ decaying memory of past shocks. Prevents "selling insurance during a crash."
  - New module: `arb_bot/crypto/hawkes_vol.py`
  - Config: `hawkes_enabled: bool`, `hawkes_baseline: float`, `hawkes_decay: float`
- **C4B.** Wire Hawkes into vol estimation — when Hawkes intensity is elevated, scale vol up (or block trades entirely). Provides a "volatility regime" signal.
  - Files: `arb_bot/crypto/engine.py`, `arb_bot/crypto/price_model.py`
- **References:** Filimonov & Sornette (2012) "Quantifying Reflexivity in Financial Markets"

### C5. Tier 3 — Input-Uncertainty-Aware Confidence (Medium Term, Future)
- **C5A.** Bootstrap vol uncertainty — resample returns history, compute vol for each subsample, generate MC paths across the vol distribution. Produces honest ~3-10x wider CIs than current Wilson CI.
  - Files: `arb_bot/crypto/price_model.py`
- **C5B.** Replace Wilson CI with Bayesian posterior — full posterior over probability incorporating vol, drift, and MC sampling uncertainty. Directly feeds into Kelly sizing for better risk management.
  - Files: `arb_bot/crypto/price_model.py`, `arb_bot/crypto/engine.py`

---

## CRYPTO PAPER TEST VERSION ROADMAP

### v17 — Defensive Regime Improvements (Tier 1-3) ✅ DEPLOYED
- Regime Kelly multipliers (high_vol=0, trending=0.4-0.5, mean_reverting=1.5)
- Regime min edge thresholds (10¢/20¢/30¢ per regime)
- VPIN halt gate (skip cycle when VPIN > 0.85)
- Counter-trend OFI filter, vol regime adjustment, mean-reverting size boost
- Conditional trend drift, transition caution zone, Z-score post-edge filter
- 4 new feature store columns for classifier training

### v18 — Micro-Momentum (Strategy B)
- In high-vol regimes (currently Kelly=0), follow OFI direction instead of skipping
- Signal: |OFI| > threshold AND regime == high_vol → trade in OFI direction
- Focus on short TTE (5-15 min) where momentum is strongest
- Reuses existing multi-timescale OFI infrastructure
- New config: `momentum_enabled`, `momentum_ofi_trigger`, `momentum_max_tte_minutes`

### v19 — Straddle / Long-Vol (Strategy A)
- Buy deep OTM contracts on both sides when Hawkes intensity spikes
- Example: BTC at $95k → buy "BTC > $96k" for $0.15 + "BTC < $94k" for $0.15
- Trigger: Hawkes intensity > threshold (e.g., > 10 jumps/day equivalent)
- Depends on Kalshi having sufficient liquidity on both OTM sides
- New module: `arb_bot/crypto/straddle.py`

### v20 — Gamma Scalp (Strategy C)
- Fade momentum after initial spike stalls (OFI returns to 0 in high-vol)
- "Reversion within the trend" — highest risk, highest reward
- Trigger: high_vol regime + large initial move + OFI reverting to neutral
- Needs substantial v18/v19 data to validate entry/exit signals
- New config: `gamma_scalp_enabled`, `gamma_scalp_min_move_pct`, `gamma_scalp_ofi_revert_threshold`

---

## POST-v20 EXPLORATION — PROFESSIONAL-GRADE UPGRADES

### P1. L2 Order Book Integration (HIGH PRIORITY)
- Subscribe to Kalshi L2 WebSocket for full depth-of-book data
- Track queue position, pull/add dynamics, spoofing patterns
- Replace trade-print-based microstructure inference with actual book state
- Enables: better fill probability estimation, queue-aware maker strategy, toxicity detection
- **Biggest single edge gap vs professional systems**

### P2. Trained Classifier Replacing Rule-Based Filters
- Train gradient-boosted model (XGBoost/LightGBM) on feature store data
- Predict win probability directly from 48 features, size off model output
- Replaces hand-tuned regime Kelly multipliers and edge thresholds
- Requires: sufficient feature store samples (target 500+ settled trades)
- Files: `arb_bot/crypto/classifier.py` (exists, currently disabled)

### P3. Cross-Venue Execution (Kalshi + Polymarket + ForecastEx)
- Wire crypto module into the existing multi-venue arb infrastructure (Phases 0-6)
- Actual arbitrage between venues, not single-venue directional betting
- Leverage existing `ExchangeAdapter` ABC, order store, legging controls
- Requires: mapping equivalent markets across venues

### P4. Historical Backtesting Framework
- Replay historical Kalshi order book snapshots + Binance tick data deterministically
- Use replay harness (Phase 5N) with recorded market data
- Validate strategies on months of data before paper testing
- Requires: historical data collection pipeline (Kalshi snapshots, Binance klines)

### P5. Portfolio-Level Kelly Optimization
- Current: size each trade independently
- Target: optimize portfolio Kelly considering correlation between open positions
- Prevents concentration risk from correlated BTC/ETH/SOL positions
- Extends Phase 4H exposure controls with proper covariance matrix

### P6. Market Making Strategy
- Post limit orders on both sides and collect spread
- Completely different from directional betting — requires inventory management
- Where most binary market profits come from at scale
- Requires: L2 data (P1), low-latency execution, adverse selection model

### P7. Alternative Data Signals
- Social sentiment (crypto Twitter/Reddit), on-chain whale alerts, Deribit options flow
- Crypto markets uniquely susceptible to social/on-chain signals
- New modules: sentiment feed, on-chain monitor, options flow tracker

### P8. Global Macro Regime Model
- Current regime detector is per-symbol microstructure-based
- Add macro regime: DXY, rates, equity vol (VIX), cross-asset correlations
- Better regime classification for longer-duration trades

### P9. Formal Risk Attribution
- Daily PnL decomposition by factor: regime timing, edge detection, sizing, execution, luck
- Identify which components contribute to/detract from returns
- Standard at any prop desk for strategy evaluation
